using System;

using System.IO;

using System.Xml;

using System.Net;

using System.Text;
using System.Text.RegularExpressions;

using System.Collections.Generic;

using Microsoft.CSharp;

using System.CodeDom;
using System.CodeDom.Compiler;

//using ProjectBase.Tools.Wiki;

namespace gWikiGrabber
{
    class Program
    {
        const string DefaultString = "String";
        const bool DefaultBool = true;
        const int DefaultNumber = 1;

        static void Main(string[] args)
        {
            Console.WriteLine("Enter the web page (NOTE: THIS MUST HAS HTTP or HTTPS):");
            Console.WriteLine();

            GetData();
        }

        static void GetData()
        {
            var web = "http://wiki.garrysmod.com/page/Category:Library_Functions";

            Console.WriteLine(web);

            byte[] row;

            try
            {
                using (var db = new WebClient())
                {
                    row = db.DownloadData(web);
                }
            }
            catch
            {
                Console.WriteLine("Web page was incorrect. Please enter the web page again:");
                GetData();
                return;
            }

            if (row == null)
            {
                Console.WriteLine("There was no data received from the web page. Please enter a new page:");
                GetData();
                return;
            }

            var ut = new UTF8Encoding();

            var page = ut.GetString(row);

            if (page == null)
            {
                Console.WriteLine("There was no data received from the web page. Please enter a new page:");
                GetData();
                return;
            }

            Console.WriteLine("Data sucessfully received from the server.");

            Console.WriteLine();
            Console.WriteLine();

            Console.WriteLine("Please enter a valid regex string in order to get the data:");

            Console.WriteLine();

            var rgx = @"(?<=\btitle="")[^""]*";

            Console.WriteLine(rgx);

            var regex = new Regex(rgx);

            var match = regex.Matches(page);

            //var print = false;

            var file = "default.txt";

            if (match.Count > 0)
            {
                Console.WriteLine("There are " + match.Count + " matches that were found, Would you like to see them in console?");

                Console.WriteLine();

                //var read = Console.ReadKey(true);

                /*if (read.Key == ConsoleKey.Enter || read.Key == ConsoleKey.Y)
                    print = true;
                else
                    print = false;
                */
                Console.WriteLine();

                Console.WriteLine("Alright, Enter a name for file you're looking to write them:");

                Console.WriteLine("NOTE: This removes any existing file, so watch out!!");

                Console.WriteLine();

                file = "any*.cs";

                Console.WriteLine(file);
            }

            /*using (var sw = new StreamWriter(file))
            {
                foreach (var m in match)
                {
                    sw.WriteLine(m);
                    if (!print) continue;
                    Console.WriteLine(m);
                }
            }*/

            List<string> cats = new List<string>();

            foreach (var m in match)
            {
                var str = m.ToString();

                if (str.Contains("/"))
                {
                    var mp = str.Split('/')[0];
                    if (!cats.Contains(mp))
                        cats.Add(mp);
                }
            }

            Dictionary<string, List<string>> cts = new Dictionary<string, List<string>>();

            foreach (var b in cats)
            {
                cts[b] = new List<string>();
            }

            foreach (var m in match)
            {
                var str = m.ToString();

                if (str.Contains("/"))
                {
                    var mp = str.Split('/');
                    if (!cts[mp[0]].Contains(mp[1]))
                        cts[mp[0]].Add(mp[1]);
                }
            }

            var comp = new CompilerParameters();

            var csharp = new CSharpCodeProvider();

            foreach (var m in cts)
            {
                if (File.Exists(m.Key + ".cs")) continue;

                var cm = new CodeCompileUnit();

                var nm = new CodeNamespace("MetroMad.Lua.gLua");

                nm.Comments.Add(new CodeCommentStatement(@"/*  AutoGeneratedCode.cs - This class Is autogenerated.

    Copyright (C) 2014  Ali Deym (https://github.com/111WARLOCK111/).

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/"));

                var imp = new CodeNamespaceImport("System");

                nm.Imports.Add(imp);

                var cls = new CodeTypeDeclaration(m.Key);

                cls.Attributes = MemberAttributes.Public;

                var meths = new CodeMemberMethod[m.Value.Count];

                int count = 0;

                //var pars = new WikiConverter();

                foreach (var db in m.Value)
                {
                    meths[count] = new CodeMemberMethod();

                    meths[count].Attributes = MemberAttributes.Public;

                    /*var reg = "(?={{)[^<]*";

                    var rex = new Regex(reg);*/

                    var UTF = new UTF8Encoding();

                    var pg = DLPage("http://wiki.garrysmod.com/index.php?title=" + m.Key + "/" + db + "&action=raw");

                    if (pg == null) continue;

                    var txt = UTF.GetString(pg);

                    string CurrentBlock = null;

                    //Dictionary<String, List<String>> Info = new Dictionary<String, List<String>>();

                    //List<CArgs> Args = new List<CArgs>();

                    //Dictionary<String, List<Tuple<String, String>>> Raw = new Dictionary<String, List<Tuple<string, string>>>();

                    Dictionary<String, Tuple<String, String>> Args = new Dictionary<string, Tuple<string, string>>();

                    string type = "";
                    string name = "";
                    string desc = "";

                    string RawName = "";
                    string RawDescription = "";
                    string RawRealm = "";

                    string rtype = "";
                    string rdesc = "";

                    foreach (var ms in txt.Split('\n'))
                    {
                        if (ms.StartsWith("{{"))
                        {
                            CurrentBlock = ms.Substring(2);
                            if (CurrentBlock == "Arg") continue;
                            //Raw.Add(CurrentBlock, new List<Tuple<string, string>>());
                        }

                        if (ms.StartsWith("}}"))
                        {
                            CurrentBlock = null;
                            type = "";
                            name = "";

                            /*RawName = "";
                            RawDescription = "";
                            RawRealm = "";*/
                        }

                        if (CurrentBlock == null) continue;

                        /*if (!Raw.ContainsKey(CurrentBlock))
                            Raw[CurrentBlock] = new List<Tuple<string, string>>();*/

                        if (!ms.Contains("=")) continue;


                        var sp = ms;

                        if (sp.StartsWith("|"))
                            sp = sp.Substring(1);

                        sp = sp.Trim();

                        if (CurrentBlock == "Arg")
                        {
                            if (sp.Split('=')[0].Trim().ToLower() == "type")
                                type = sp.Split('=')[1].Trim();

                            if (sp.Split('=')[0].Trim().ToLower() == "name")
                                name = sp.Split('=')[1].Trim();

                            if (sp.Split('=')[0].Trim().ToLower() == "desc")
                                desc = sp.Split('=')[1].Trim();

                            if (name != "" && type != "" && desc != "")
                            {
                                Args.Add((Args.ContainsKey(name) ? name + "1" : name), new Tuple<String, String>(type, desc));
                                name = "";
                                type = "";
                                desc = "";
                            }
                            continue;
                        }

                        if (CurrentBlock == "Func")
                        {
                            if (sp.Split('=')[0].Trim().ToLower() == "name")
                                RawName = sp.Split('=')[1].Trim();

                            if (sp.Split('=')[0].Trim().ToLower() == "description")
                                RawDescription = sp.Split('=')[1].Trim();

                            if (sp.Split('=')[0].Trim().ToLower() == "realm")
                                RawRealm = sp.Split('=')[1].Trim();

                            continue;
                        }

                        if (CurrentBlock == "Ret")
                        {
                            if (rtype != "" && rdesc != "")
                                continue;

                            if (sp.Split('=')[0].Trim().ToLower() == "type")
                                rtype = sp.Split('=')[1].Trim();

                            if (sp.Split('=')[0].Trim().ToLower() == "desc")
                                rdesc = sp.Split('=')[1].Trim();
                        }


                        //Raw[CurrentBlock].Add(new Tuple<string, string>(sp.Split('=')[0].Trim(), sp.Split('=')[0].Trim()));
                    }

                    /*foreach (var ms in txt.Split('\n'))
                    {
                        var ps = ms.Trim();

                        if (String.IsNullOrWhiteSpace(ps)) continue;

                        if (ps.StartsWith("{{"))
                        {
                            CurrentBlock = ps.Substring(2);

                            Info[CurrentBlock] = new List<string>();
                        }

                        if (ps.StartsWith("}}"))
                            CurrentBlock = null;

                        if (CurrentBlock == null) continue;

                        Info[CurrentBlock].Add(ps.Substring(1).Trim());
                    }

                    bool found = false;

                    if (Info.ContainsKey("Syntax"))
                    {
                        foreach (var ss in Info["Syntax"])
                        {
                            if (ss.StartsWith("Arg"))
                            {
                                var name = ss.Substring(3);

                                var id = int.Parse(name.Substring(0, 1));
                                if (Args[id] == null)
                                {
                                    Args[id] = new CArgs();
                                }

                                name = ss.Substring(1);

                                var value = name;

                                value = value.Split('=')[1].Trim();

                                name = name.Split('=')[0].Trim();

                                if (name.ToLower() == "name") Args[id].Name = value;
                                if (name.ToLower() == "type") Args[id].Type = Type.GetType(value);
                                if (name.ToLower() == "Desc") Args[id].Description = value;
                                if (name.ToLower() == "Req") Args[id].Optional = bool.Parse(value);
                            }

                            if (ss.StartsWith("Returns"))
                                found = true;
                        }
                    }

                    if (found)
                    {
                        if ((Info["Syntax"].Find(x => x.StartsWith("Returns")).Replace("Returns = ", "")).ToLower() == "number")
                            meths[count].ReturnType = new CodeTypeReference(typeof(float));
                    }*/

                    meths[count].Name = RawName;

                    //var codevalue = new CodeParameterDeclarationExpression[Args.Count];

                    //var mtch = rex.Match(UTF.GetString(pg));
                    if (RawRealm != "")
                        meths[count].Comments.Add(new CodeCommentStatement("<realm>" + RawRealm + "</realm>"));

                    if (RawDescription != "")
                        meths[count].Comments.Add(new CodeCommentStatement("<summary>" + RawDescription + "</summary>"));

                    foreach (var arg in Args)
                    {
                        Type tp = null;

                        if (arg.Value.Item1.ToLower() == "number")
                            tp = typeof(float);

                        if (arg.Value.Item1.ToLower() == "string")
                            tp = typeof(string);

                        meths[count].Parameters.Add(new CodeParameterDeclarationExpression((tp == null ? arg.Value.Item1 : tp.ToString()), arg.Key));
                        meths[count].Comments.Add(new CodeCommentStatement("<param name=\"" + arg.Key + "\">" + arg.Value.Item2 + (arg.Value.Item2.EndsWith(".") ? "" : ".") + "</param>"));
                    }

                    if (rtype != "" && rdesc != "")
                        meths[count].Comments.Add(new CodeCommentStatement("<return>" + rtype + "|" + rdesc + "</return>"));

                    if (rtype != "")
                    {
                        meths[count].ReturnType = new CodeTypeReference((rtype.ToLower() == "number" ? DefaultNumber.GetType().ToString() : (rtype.ToLower() == "string" ? DefaultString.GetType().ToString() : (rtype.ToLower() == "boolean" ? DefaultBool.GetType().ToString() : rtype))));

                        if (rtype.ToLower() == "number")
                            meths[count].Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(DefaultNumber)));

                        else if (rtype.ToLower() == "string")
                            meths[count].Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(DefaultString)));

                        else if (rtype.ToLower() == "boolean")
                            meths[count].Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(DefaultBool)));

                        else
                            meths[count].Statements.Add(new CodeMethodReturnStatement(new CodeObjectCreateExpression(rtype, new CodeExpression[] { })));
                    }

                    count++;
                }

                foreach (var sp in meths)
                {
                    cls.Members.Add(sp);
                }

                nm.Types.Add(cls);

                cm.Namespaces.Add(nm);

                IndentedTextWriter tw = null;

                try
                {
                    tw = new IndentedTextWriter(new StreamWriter(m.Key + ".cs", false), "    ");
                }
                catch
                {
                    Console.WriteLine("Done!");
                    Console.WriteLine("Press any key to exit...");

                    Console.ReadKey();

                    Environment.Exit(0);
                }

                csharp.GenerateCodeFromCompileUnit(cm, tw, new CodeGeneratorOptions());

                tw.Close();

                Console.WriteLine("CLASS " + m.Key + ".cs successfully written!");
            }

            Console.WriteLine("Finished! Check the existing file called " + file + " ;)");

            Console.WriteLine("If you're not going to continue, just close this application.");

            Console.WriteLine("Enter the web page (NOTE: THIS MUST HAS HTTP or HTTPS):");

            Console.WriteLine();
            Console.WriteLine();

            //GetData();
        }

        static byte[] DLPage(string page)
        {
            byte[] row;

            try
            {
                using (var db = new WebClient())
                {
                    row = db.DownloadData(page);
                }
            }
            catch
            {
                Console.WriteLine("Web page was incorrect. Please enter the web page again:");
               // return DLPage(page);
                return null;
            }

            return row;
        }
    }
}
